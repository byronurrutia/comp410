# COMP 410 PROFESSOR KYLE DEWEY

## Class Description

Programming techniques in the logic programming language Prolog. Prenex conjunctive
normal form and grammatical algorithms. Tableaux, sequenzen, resolution and other
semi-decision procedures. Closures of relations, fixed point theory, control mechanisms,
relationship to functional programming.

## Learning Objectives

Successful students will be able to:
- Recognize problems which are well-suited to the logic programming paradigm
- Write Prolog and Mercury programs which manipulate lists, solve NP-complete
problem instances, automatically generate software tests, and interpret other Prolog
programs
- Understand the connection between formal logic and logic programming, and the
theoretical underpinnings of logic programming

## Course Background, Emphasis, and Design

Logic programming, while often understated, is a major programming paradigm. In my
opinion, logic programming is well-suited to problems with one or more of the following
properties:
- There are many distinct answers of interest
- Solving the problem requires trying different approaches and seeing which works
- Answers can be described easily, but it’s difficult to formulate how to arrive at an
answer

This course emphases the use of logic programming to solve problems, along with
programming techniques which are unique to the logic programming paradigm. To this
end, there will be a multitude of programming assignments, most of which require you to
write code. This code will be written in either Prolog or Mercury, both of which are
reputable logic programming languages.

Will you ever use Prolog ever again? Honestly, probably not. However, my goal isn’t to
teach Prolog, but rather the ideas behind Prolog. Logic programming techniques can
be implemented in more mainstream, non-logical languages; it’s merely inconvenient
opposed to impossible (similarly, object-oriented programming can be done in C, even
though C predates object-oriented programming).

